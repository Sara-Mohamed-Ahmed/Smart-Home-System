/*
 * Timers_Program.c

 *
 *  Created on: Aug 8, 2024
 *      Author: PC-SHOP
 */

#include "../../LIB/STD_TYPES.h"
#include "../../LIB/BIT_MATH.h"
#include "Timers_Config.h"
#include "Timers_Interface.h"
#include "Timers_Privet.h"

static void (*TIM0_PFNOM)(void);
static void (*TIM0_PFCTC)(void);

void TIM0_voidNormalMode(void){
	//SELECT NORMAL MODE
	CLR_BIT(TIM0_TCCR0_REG, TCCRO_WGM00);
	CLR_BIT(TIM0_TCCR0_REG, TCCRO_WGM01);
	//SELCT FACTOR 8 ( Clock Select OR PRESCALER)
	CLR_BIT(TIM0_TCCR0_REG, TCCRO_CS00);
	CLR_BIT(TIM0_TCCR0_REG, TCCRO_CS02);
	SET_BIT(TIM0_TCCR0_REG, TCCRO_CS01);
	//ENABLE THE PIE (ENABLE THE NORMAL INTERRUPT)
	SET_BIT(TIM0_TIMSK_REG,TIMSK_TOIE0);
	//SET PRELOAD
	TIM0_TCNT0_REG=192;
}
void TIM0_NormalSetCallBack(void(*Copy_u8pf)(void)){
	TIM0_PFNOM=Copy_u8pf;
}


void __vector_11(void)  __attribute__((signal));

void __vector_11(void)
{
	//DESIRED TIME=1sec =(1000000)
	static u16 Local_u8Counter=0;
	Local_u8Counter++;
	if (Local_u8Counter==3907){
		TIM0_PFNOM();
		Local_u8Counter=0;
		TIM0_TCNT0_REG=192;
	}


}

void TIM0_voidCTCMode(void){
	//SELECT NORMAL MODE
	CLR_BIT(TIM0_TCCR0_REG, TCCRO_WGM00);
	SET_BIT(TIM0_TCCR0_REG, TCCRO_WGM01);
	//SELCT FACTOR 8 ( Clock Select OR PRESCALER)
	CLR_BIT(TIM0_TCCR0_REG, TCCRO_CS00);
	CLR_BIT(TIM0_TCCR0_REG, TCCRO_CS02);
	SET_BIT(TIM0_TCCR0_REG, TCCRO_CS01);
	//ENABLE THE PIE (ENABLE THE CTC INTERRUPT)
	SET_BIT(TIM0_TIMSK_REG,TIMSK_OCIE0);
	// SET INITIAL VALUE FOR THE OCR
	TIM0_OCR0_REG=99;

}

void TIM0_CTCSetCallBack(void(*Copy_u8pf)(void)){
	TIM0_PFCTC=Copy_u8pf;
}

void __vector_10(void)  __attribute__((signal));

void __vector_10(void)
{
	static u16 Local_u8Counter=0;
	Local_u8Counter++;
	if (Local_u8Counter==10000){
		TIM0_PFCTC();
		Local_u8Counter=0;
	}
}


void TIM0_voidFastPWMInit(void){
	//SELCT FACTOR 8 ( Clock Select OR PRESCALER)
	CLR_BIT(TIM0_TCCR0_REG, TCCRO_CS00);
	CLR_BIT(TIM0_TCCR0_REG, TCCRO_CS02);
	SET_BIT(TIM0_TCCR0_REG, TCCRO_CS01);
	//SELECT PWM MODE
	SET_BIT(TIM0_TCCR0_REG, TCCRO_WGM00);
	SET_BIT(TIM0_TCCR0_REG, TCCRO_WGM01);

	//select non inverting mode
	CLR_BIT(TIM0_TCCR0_REG, TCCRO_COM00);
	SET_BIT(TIM0_TCCR0_REG, TCCRO_COM01);

}

void TIM0_voidSetCompareMatch (u8 Copy_u8Value){
	TIM0_OCR0_REG=Copy_u8Value;
}


void TIM1_voidFastPWM(void){
	//SELLECT MODE 14
	SET_BIT(TIM1_TCCR1B_REG,3);
	SET_BIT(TIM1_TCCR1B_REG,4);
	CLR_BIT(TIM1_TCCR1A_REG,0);
	SET_BIT(TIM1_TCCR1A_REG,1);
	 // SELECT NON INVERTING
	CLR_BIT(TIM1_TCCR1A_REG,6);
	SET_BIT(TIM1_TCCR1A_REG,7);

	//SELECT PRESCALER
	CLR_BIT(TIM1_TCCR1B_REG,0);
	CLR_BIT(TIM1_TCCR1B_REG,2);
	SET_BIT(TIM1_TCCR1B_REG,1);

	// MAX VALUE TO OVERFLOW
	TIM1_ICR1_REG=19999;

	//SET ANGLE
	TIM1_OCR1A_REG=999; //angle 0
	//TIM1_OCR1A_REG=2000; //angle 180

}

void Close_Door(void){
	//SELLECT MODE 14
	SET_BIT(TIM1_TCCR1B_REG,3);
	SET_BIT(TIM1_TCCR1B_REG,4);
	CLR_BIT(TIM1_TCCR1A_REG,0);
	SET_BIT(TIM1_TCCR1A_REG,1);
	 // SELECT NON INVERTING
	CLR_BIT(TIM1_TCCR1A_REG,6);
	SET_BIT(TIM1_TCCR1A_REG,7);

	//SELECT PRESCALER
	CLR_BIT(TIM1_TCCR1B_REG,0);
	CLR_BIT(TIM1_TCCR1B_REG,2);
	SET_BIT(TIM1_TCCR1B_REG,1);

	// MAX VALUE TO OVERFLOW
	TIM1_ICR1_REG=19999;

	//SET ANGLE
	TIM1_OCR1A_REG=999; //angle 0
	//TIM1_OCR1A_REG=2000; //angle 180

}


void Open_Door(void){
	//SELLECT MODE 14
	SET_BIT(TIM1_TCCR1B_REG,3);
	SET_BIT(TIM1_TCCR1B_REG,4);
	CLR_BIT(TIM1_TCCR1A_REG,0);
	SET_BIT(TIM1_TCCR1A_REG,1);
	 // SELECT NON INVERTING
	CLR_BIT(TIM1_TCCR1A_REG,6);
	SET_BIT(TIM1_TCCR1A_REG,7);

	//SELECT PRESCALER
	CLR_BIT(TIM1_TCCR1B_REG,0);
	CLR_BIT(TIM1_TCCR1B_REG,2);
	SET_BIT(TIM1_TCCR1B_REG,1);

	// MAX VALUE TO OVERFLOW
	TIM1_ICR1_REG=19999;

	//SET ANGLE

	TIM1_OCR1A_REG=2000; //angle 180

}



